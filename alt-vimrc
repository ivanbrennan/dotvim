" ::::::::: vimrc :::::::::::::::::::::::::::::::::::::

set nocompatible                " be iMproved
set encoding=utf-8              " default encoding to UTF-8
set t_Co=256                    " 256 color terminal

" ::::::::: Plugins ::::::::::::::::::::::: {{{1

filetype off                    " required for Vundle!

set runtimepath+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'gmarik/Vundle.vim'

" github repos: general
Bundle 'ivanbrennan/quickfix-toggle'
Bundle 'kien/ctrlp.vim'
Bundle 'rking/ag.vim'
" Bundle 'bling/vim-airline'
" Bundle 'SirVer/ultisnips'
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-commentary'
" Bundle 'tpope/vim-endwise'
Bundle 'tpope/vim-unimpaired'
" Bundle 'tpope/vim-rails'
" Bundle 'tpope/vim-bundler'
Bundle 'AndrewRadev/splitjoin.vim'
Plugin 'jwhitley/vim-matchit'
Plugin 'sjl/gundo.vim'
Bundle 'vim-ruby/vim-ruby'
Bundle 'thoughtbot/vim-rspec'
Bundle 'kchmck/vim-coffee-script'
Bundle 'eiginn/netrw'
Bundle 'nelstrom/vim-qargs'

" github repos: colors
Bundle 'gregsexton/Muon'
Bundle 'guns/xterm-color-table.vim'
Bundle 'shawncplus/Vim-toCterm'
Bundle 'vim-scripts/hexHighlight.vim'

call vundle#end()
filetype plugin indent on       " required for Vundle!

" ::::::::: Settings :::::::::::::::::::::: {{{1

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· options Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2

set nrformats=
set showcmd
set complete-=i                 " don't bog completion down
set guioptions-=L
set guioptions-=r

" notifications
set shortmess+=I                " disable intro message
set visualbell                  " don't beep

" posterity
set backup                      " backup files
set undofile                    " persistent undo
set backupdir=~/.vim/backup     " backups here
set undodir=~/.vim/undo         " undo files here
set directory=~/.vim/tmp        " temp files here
set history=500                 " history 500-deep

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· netrw Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
let g:netrw_list_hide='\(^\|\s\s\)\zs\.\S\+,^DS_Store$'
let g:netrw_hide=1              " hide hidden files
let g:netrw_dirhistmax=100      " keep more history
let g:netrw_altfile=1           " last edited file '#'
let g:netrw_liststyle=0         " thin
let g:netrw_altv=1              " open files on right
let g:netrw_preview=1           " open previews vertically
let g:netrw_use_errorwindow=0   " suppress error window

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· ctrlp Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
let g:ctrlp_show_hidden = 1     " include hidden files
let g:ctrlp_match_window = 'max:12'

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· Ag Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
if executable('ag')
  let g:aghighlight=1
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
  let g:ctrlp_use_caching = 0
endif

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· vim-rspec Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
let g:rspec_runner = "os_x_iterm"

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· editing Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
set hidden                      " allow hidden buffers
set backspace=indent,eol,start  " backspace through everything
set textwidth=0                 " no autowrap

" formatting
set formatprg=par               " gq -> par, gw -> internal
set formatoptions-=o            " don't auto-comment with o or O
silent! set formatoptions+=j    " let J handle comments if supported

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· navigation Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
set scrolloff=1
set sidescroll=1                " smooth sidescroll
set mouse+=a
if &term =~ '^screen'           " extended mouse mode
  set ttymouse=xterm2
endif

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· searching Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
set incsearch                   " incremental searching
set ignorecase                  " searches are case insensitive...
set smartcase                   " ...unless they contain a capital letter

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· appearance Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
syntax enable                   " syntax highlighting, local overrides
set number                      " line numbers
set title                       " xterm title
set nowrap                      " don't wrap lines
" set fillchars+=vert:\           " clean dividers
set fillchars=vert:\|,fold:-
set cursorline                  " cursorline on
set foldmethod=marker           " fold markers
augroup CursorGroup             " clear cursorline highlight
  autocmd!
  autocmd BufReadPost * call      RestoreCrsr()
augroup END

" cursor
set guicursor=n-v-c:block-blinkon0
set guicursor+=ve:ver35
set guicursor+=o:hor50
set guicursor+=i-ci:ver25
set guicursor+=r-cr:hor20
set guicursor+=sm:block-blinkon0

" whitespace
set tabstop=2                   " tab is two spaces
set softtabstop=2               " softtab is two spaces
set shiftwidth=2                " autoindent is two spaces
set expandtab                   " convert tabs to spaces

set list                        " show invisible characters
set listchars=""                " reset the listchars
set listchars=tab:â–¸\            " tab
set listchars+=trail:Â·          " trailing space
set listchars+=extends:Â»        " continues offscreen
set listchars+=precedes:Â«       " precedes offscreen

" colors
colorscheme irb256

" nice colorschemes {{{
let g:nice_schemes =
      \[
      \"eivel",
      \"eivel_dark",
      \"eivel_light",
      \"github",
      \"hemisu",
      \"ivisu",
      \"muon",
      \"mustang",
      \"mustangblue",
      \"smyck",
      \"smyckblue",
      \"solarized",
      \"ir_black",
      \"tir_black",
      \"xoria256",
      \]
" }}}
" fonts {{{
set guifont=Sauce\ Code\ Powerline:h14
let g:font_dict =
      \{
      \"Anonymous Pro":         3,
      \"Inconsolata":           1,
      \"Menlo":                 0,
      \"Monaco":               -2,
      \"Source Code Pro":      -1,
      \"Sauce Code Powerline": -1,
      \"Ubuntu Mono":           3,
      \}
" }}}

" status line
set laststatus=2                " show statusline

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· wild settings Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
set wildmenu
set wildmode=longest,list

" output and VCS
set wildignore+=*.o,*.out,*.obj,.git,*.rbc,*.rbo,*.class,.svn,*.gem
" archives
set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz
" bundler and sass
set wildignore+=*/vendor/gems/*,*/vendor/cache/*,*/.bundle/*,*/.sass-cache/*
" librarian-chef, vagrant, test-kitchen and Berkshelf
set wildignore+=*/tmp/librarian/*,*/.vagrant/*,*/.kitchen/*,*/vendor/cookbooks/*
" rails temporary asset caches
set wildignore+=*/tmp/cache/assets/*/sprockets/*,*/tmp/cache/assets/*/sass/*
" temp and backup files
set wildignore+=*.swp,*~,._*
" OSX bullshit
set wildignore+=*.DS_Store

" ::::::::: Mappings :::::::::::::::::::::: {{{1

" leaders
map <Space> <Leader>
let maplocalleader=','
set timeout timeoutlen=250 ttimeoutlen=100

" source / edit vimrc
noremap <LocalLeader>` :source $MYVIMRC<CR>
noremap <LocalLeader>`, :tabedit $MYVIMRC<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· keyboard layouts Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
noremap <LocalLeader>kq :call Keyboard("qwerty")<CR>
noremap <LocalLeader>kw :call Keyboard("workman")<CR>

function! QWERTYMaps() " {{{3
  " enter command mode
  " noremap  ; :
  noremap <Leader>; :
  noremap q; q:

  " exit insert mode
  inoremap kj <Esc>`^
  inoremap jk <Esc>`^

  " shell command
  noremap <Leader>1 :!

  " navigate
  nnoremap <C-J> <C-W>j
  nnoremap <C-K> <C-W>k
  nnoremap <C-H> <C-W>h
  nnoremap <C-L> <C-W>l

  " rearrange
  noremap <C-W><C-J> <C-W>J
  noremap <C-W><C-K> <C-W>K
  noremap <C-W><C-H> <C-W>H
  noremap <C-W><C-L> <C-W>L
endfunction

function! QWERTYUnmaps() " {{{3
  " enter command mode
  unmap  ;
  unmap q;

  " exit insert mode
  iunmap    kj
  iunmap    jk

  " shell command
  unmap <Leader>1

  " navigate
  unmap <C-J>
  unmap <C-K>
  unmap <C-H>
  unmap <C-L>

  " rearrange
  unmap <C-W><C-J>
  unmap <C-W><C-K>
  unmap <C-W><C-H>
  unmap <C-W><C-L>
endfunction

function! WorkmanMaps() " {{{3
  " (E)xit insert mode
  inoremap <C-E> <Esc>`^
  inoremap <C-K> <C-E>

  " (O)pen line -> (L)ine
  noremap l o
  noremap o l
  noremap L O
  noremap O L
  " Search (N)ext -> (J)ump
  noremap j n
  noremap n j
  noremap J N
  noremap N J
  " (E)nd of word -> brea(K) of word
  noremap k e
  noremap e k
  noremap K E
  noremap E K
  " (Y)ank -> (H)aul
  noremap h y
  noremap y h
  noremap H Y
  noremap Y H

  " navigate
  noremap <C-O> <C-W>l
  noremap <C-L> <C-O>
  noremap <C-N> <C-W>j
  noremap <C-J> <C-N>
  noremap <C-E> <C-W>k
  noremap <C-K> <C-E>
  noremap <C-Y> <C-W>h
  noremap <C-H> <C-Y>

  " unmap conflicting Surround keymaps
  nunmap ySS
  nunmap ySs
  nunmap yS
  nunmap ys
  nunmap yss
endfunction

function! WorkmanUnmaps() " {{{3
  " (E)xit insert mode
  iunmap <C-E>
  iunmap <C-K>

  " (O)pen line -> (L)ine
  unmap l
  unmap o
  unmap L
  unmap O
  " Search (N)ext -> (J)ump
  unmap j
  unmap n
  unmap J
  unmap N
  " (E)nd of word -> brea(K) of word
  unmap k
  unmap e
  unmap K
  unmap E
  " (Y)ank -> (H)aul
  unmap h
  unmap y
  unmap H
  unmap Y

  " navigate
  unmap <C-O>
  unmap <C-L>
  unmap <C-N>
  unmap <C-J>
  unmap <C-E>
  unmap <C-K>
  unmap <C-Y>
  unmap <C-H>
endfunction

" initialize {{{3
call QWERTYMaps()

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· terminal key codes Â·Â·Â·Â·Â·Â·Â· {{{2
" Add tmux's higher F-key capabilities
if &term =~ "screen"
  set  <F13>=[1;2P
  set  <F14>=[1;2Q
  set  <F15>=[1;2R
  set  <F16>=[1;2S
  set  <F17>=[1;5P
  set  <F18>=[1;5Q
  set  <F19>=[1;5R
  set  <F20>=[1;5A
  set  <F21>=[1;5B
  set  <F22>=[1;5C
  set  <F23>=[1;5D
elseif &term =~ "xterm"
  set  <F13>=O2P
  set  <F14>=O2Q
  set  <F15>=O2R
  set  <F16>=O2S
  set  <F17>=O5P
  set  <F18>=O5Q
  set  <F19>=O5R
  set  <F20>=[1;5A
  set  <F21>=[1;5B
  set  <F22>=[1;5C
  set  <F23>=[1;5D
endif

" use some unused function key codes to
" make special key combos work in terminal
map  <F13> <C-CR>
map! <F13> <C-CR>
map  <F14> <S-CR>
map! <F14> <S-CR>

map  <F15> <C-Space>
map! <F15> <C-Space>
map  <F16> <S-Space>
map! <F16> <S-Space>

map  <F17> <C-BS>
map! <F17> <C-BS>

map  <F18> <M-Tab>
map! <F18> <M-Tab>
map  <F19> <M-S-Tab>
map! <F19> <M-S-Tab>

map  <F20> <C-Up>
map! <F20> <C-Up>
map  <F21> <C-Down>
map! <F21> <C-Down>

map  <F22> <C-Tab>
map! <F22> <C-Tab>
map  <F23> <C-S-Tab>
map! <F23> <C-S-Tab>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· buffers Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
" netrw
noremap <silent> <Leader>e :call ExToggle("")<CR>
noremap <silent> <Leader>,e :call ExToggle(getcwd())<CR>
noremap <silent> <Leader><Tab> :call VexToggle("")<CR>
noremap <silent> <Leader>,<Tab> :call VexToggle(getcwd())<CR>

" from ./vim/after/ftplugin/netrw.vim
"   Select file/dir:  f
"   Refresh listing: <LocalLeader>l
"   Set treetop dir: <LocalLeader>t

" search
noremap <Leader><Space> /
noremap <Leader>a :Ag! 

" list
noremap <LocalLeader><Space> :buffers<CR>
noremap <Leader>p :CtrlPBuffer<CR>
noremap <Leader>b :echo bufnr('%')<CR>

" open from ~
noremap <Leader>eh :edit ~/

" open from /
nmap <Leader>ew :edit 
nmap <Leader>es :split 
nmap <Leader>ev :vsplit 
nmap <Leader>et :tabedit 

" edit from %
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<CR>
nmap <LocalLeader>ew :edit %%
nmap <LocalLeader>es :split %%
nmap <LocalLeader>ev :vsplit %%
nmap <LocalLeader>et :tabedit %%
nmap <LocalLeader>ww :write %%

" close
noremap <LocalLeader>d :bdelete<CR>
" noremap <silent> <LocalLeader>c :call BClose()<CR>

" current directory
noremap <Leader>/ :pwd<CR>
noremap <LocalLeader>t :lcd %:h<CR>

" cycle
noremap   <M-Tab> :bnext<CR>
noremap <M-S-Tab> :bprevious<CR>

" reload
noremap <LocalLeader>l :call ReLoadBuffers()<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· editing Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
" open above / below current line
inoremap <S-CR> <C-O>O
inoremap <C-CR> <C-O>o

" double backspace
inoremap <C-BS> <BS><BS>

" insert above / below current line
noremap <S-CR> mzO<Esc>j`z
noremap <C-CR> mzo<Esc>k`z

" commentary
xmap <Leader>c  <Plug>Commentary
nmap <Leader>c  <Plug>Commentary
omap <Leader>c  <Plug>Commentary
nmap <Leader>cc <Plug>CommentaryLine

" bubble text
nnoremap <silent> <C-Up> mZ:move .-2<CR>==`Z
vnoremap          <C-Up> :move '<-2<CR>gv=gv
inoremap          <C-Up> <Esc>:move .-2<CR>==gi
nnoremap <silent> <C-Down> mZ:move .+1<CR>==`Z
vnoremap          <C-Down> :move '>+1<CR>gv=gv
inoremap          <C-Down> <Esc>:move .+1<CR>==gi

vnoremap <C-Left> <Esc>`<<Left>i_<Esc>mz"_xgvx`zPgv<Left>o<Left>o
vnoremap <C-Right> <Esc>`><Right>gvxpgv<Right>o<Right>o

" whole line completion
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<TAB>"
    else
        return "\<C-P>"
    endif
endfunction
inoremap <expr> <silent> <TAB> InsertTabWrapper()
inoremap <S-TAB> <C-N>

inoremap <C-L> <C-X><C-L>

" jump back a word in insert mode
inoremap <C-B> <C-O>b

" autocomplete parens, brackets, braces
inoremap (<CR> (<CR>)<Esc>O<Tab>
inoremap [<CR> [<CR>]<Esc>O<Tab>
inoremap {<CR> {<CR>}<Esc>O<Tab>

" clipboard
noremap <Leader>8 "*

" copy to end of line
noremap <LocalLeader>c "*yg_

" paste toggle
noremap <LocalLeader>p :set paste! paste?<CR>
noremap           <F4> :set paste! paste?<CR>
set pastetoggle=<F4>

" toggle case
inoremap `` <Esc>viwg~gi

" toggle filetype
noremap <silent> <LocalLeader>f, :call FileTypeToggle(1)<CR>
noremap <silent>  <LocalLeader>f :call FileTypeToggle(0)<CR>
" toggle html
inoremap <silent> `h X<C-O>:call HTMLTypeToggle()<CR><BS>

" format entire file
noremap <LocalLeader>fef :normal! gg=G``<CR>

" toggle Gundo
noremap <Leader>g :GundoToggle<CR>

" previous / next braces
onoremap in :<C-U>call NextTextObject('i')<CR>
xnoremap in :<C-U>call NextTextObject('i')<CR>
onoremap an :<C-U>call NextTextObject('a')<CR>
xnoremap an :<C-U>call NextTextObject('a')<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· navigation Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
" sensible marks
noremap ` '
noremap ' `

" soft line-breaks
noremap    <Up> gk
noremap  <Down> gj
" behave normally if popup-menu visible
inoremap   <Up> <C-R>=pumvisible() ? "\<lt>Up>" : "\<lt>C-O>gk"<CR>
inoremap <Down> <C-R>=pumvisible() ? "\<lt>Down>" : "\<lt>C-O>gj"<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· searching Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
" slash
nnoremap <C-Space> /
nnoremap <S-Space> ?

" repeat last char search
noremap + ;
noremap _ ,

" find word under cursor
noremap <silent> <Leader>f :set foldenable!<CR>
      \:let view=winsaveview()<CR>#*
      \:call winrestview(view)<CR>:set foldenable!<CR>

" code-search word under cursor
nnoremap K :Ag!<CR>

" toggle search highlighting
noremap <Leader>l :nohlsearch<CR><C-L>
noremap <Leader>h :set hlsearch! hlsearch?<CR>

" find merge conflicts
noremap <silent> <LocalLeader>m <ESC>/\v^[<=>]{7}( .*\|$)<CR>

" toggle diff
noremap <silent> <Leader>d :call DiffToggle()<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· splits & tabs Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
" splits
noremap <Leader>s :split<CR>
noremap <Leader>v :vsplit<CR>
noremap <silent> <Leader>o :only<CR>
noremap <Leader>k :quit<CR>

"resize
noremap <Leader>- <C-W>_
noremap <Leader>0 <C-W><Bar>
noremap <Leader>= <C-W>=

" tabs
noremap <C-S-Tab> :tabprevious<CR>
noremap   <C-Tab> :tabnext<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· appearance Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
noremap <LocalLeader>,w :setlocal wrap! linebreak! list! wrap?<CR>

if has("gui_running")
  noremap <LocalLeader>,t :call TransparencyToggle(5)<CR>
end

" fonts
noremap <silent> <LocalLeader>= :call FontCycle(1)<CR>:echo getfontname()<CR>
noremap <silent> <LocalLeader>- :call FontCycle(-1)<CR>:echo getfontname()<CR>

" colors
noremap <silent> <LocalLeader>] :call ColorCycle(1)<CR>:colorscheme<CR>
noremap <silent> <LocalLeader>[ :call ColorCycle(-1)<CR>:colorscheme<CR>

" background
noremap <LocalLeader>b :call ToggleBG()<CR>:echo &background<CR>

" info
noremap <LocalLeader>h :call HexHighlight()<CR>
noremap <LocalLeader>y :call SynStack()<CR>

" line numbers
noremap <Leader>n :call NumberToggle()<CR>
noremap <Leader>r :set relativenumber! relativenumber?<CR>

" foldcolumn
noremap <silent> <Leader>z :call FoldColToggle(4)<CR>

" cursor
noremap <silent> <LocalLeader>cc :set cursorcolumn!<CR>
noremap <silent> <LocalLeader>cl :call CursorLineToggle()<CR>

" colorcolumn
noremap <silent> <LocalLeader>1 :call ColorColToggle()<CR>

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· evaluation Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
" RSpec
noremap <Leader>tt :call RunCurrentSpecFile()<CR>
noremap <Leader>t<Space> :call RunNearestSpec()<CR>
noremap <Leader>tl :call RunLastSpec()<CR>
noremap <Leader>ta :call RunAllSpecs()<CR>

" ::::::::: Abbreviations ::::::::::::::::: {{{1
" common typos
noreabbrev verison version
noreabbrev funiction function
noreabbrev funcition function
noreabbrev funciotn function
noreabbrev funciton function
noreabbrev docuemt document
noreabbrev docuemtn document
noreabbrev hte the
noreabbrev edn end

" ::::::::: Autocommands :::::::::::::::::: {{{1

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· vimrc Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
augroup VimrcGroup
  autocmd!
  autocmd BufWritePost $MYVIMRC nested source $MYVIMRC
  for scheme in g:nice_schemes
    execute 'autocmd BufWritePost ~/.vim/colors/'. scheme . '.vim source $MYVIMRC'
  endfor
augroup END

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· netrw Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
augroup NetrwGroup
  autocmd!
  " autocmd BufEnter * call NormalizeWidths()
augroup END

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· git Â·Â· Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
augroup GitGroup
  autocmd!
  au FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])
augroup END

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· ruby Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
augroup RubyGroup
  autocmd!
  autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete
  " complete buffer loading can cause code execution
  " turn this off if it's a concern
  autocmd FileType ruby,eruby let g:rubycomplete_buffer_loading=1
  autocmd FileType ruby,eruby let g:rubycomplete_classes_in_global=1
  autocmd FileType ruby,eruby let g:rubycomplete_rails = 1
  autocmd FileType ruby,eruby :inoreabbrev <buffer> erb <% %><C-O>F<Space>
  autocmd FileType ruby,eruby :inoreabbrev <buffer> erp <%= %><C-O>F<Space>
  autocmd FileType ruby,eruby :inoreabbrev <buffer> erc <%# %><C-O>F<Space>
augroup END

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· markdown Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
augroup MarkdownGroup
  autocmd!
  autocmd Bufread,BufNewFile *.md set filetype=markdown
augroup END

" ::::::::: Functions ::::::::::::::::::::: {{{1

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· netrw Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! ExToggle(dir)
  if &filetype != "netrw"
    call ExOpen(a:dir)
  else
    call ExClose()
  endif
endf

fun! ExOpen(dir)
  let g:netrw_browse_split=0    " open files in current window
  let g:netrw_banner=1          " banner
  exe "Explore " . a:dir
endf

fun! ExClose()
  while &filetype == "netrw"
    exe "normal! \<C-O>"
  endw
endf

fun! VexToggle(dir)
  if exists("t:vex_buf_nr")
    call VexClose()
  else
    call VexOpen(a:dir)
  endif
endf

fun! VexOpen(dir)
  let g:netrw_browse_split=4    " open files in previous window
  let g:netrw_banner=0          " no banner
  let vex_width = 27

  exe "Vexplore " . a:dir
  let t:vex_buf_nr = bufnr("%")
  wincmd H

  call VexSize(vex_width)
endf

fun! VexClose()
  let cur_win_nr = winnr()
  let target_nr = ( cur_win_nr == 1 ? winnr("#") : cur_win_nr )

  1wincmd w
  close
  unlet t:vex_buf_nr

  exe (target_nr - 1) . "wincmd w"
  call NormalizeWidths()
endf

fun! VexSize(vex_width)
  exe "vertical resize" . a:vex_width
  set winfixwidth
  call NormalizeWidths()
endf

fun! NormalizeWidths()
  let eadir_pref = &eadirection
  set eadirection=hor
  set equalalways! equalalways!
  let &eadirection = eadir_pref
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· filetype Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! FileTypeToggle(num)
  if a:num > 0 || !exists("b:alt_ftype")
    let b:alt_ftype = &filetype
    let   &filetype = input("enter FileType: ")
  else
    let     new_alt = &filetype
    let   &filetype = b:alt_ftype
    let b:alt_ftype = new_alt
  end
endf

fun! HTMLTypeToggle()
  if exists("b:alt_ftype")
    let &filetype = b:alt_ftype
    unlet b:alt_ftype
  else
    let b:alt_ftype = &filetype
    set filetype=html
  end
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· splits Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! BClose()
  silent! bprevious | split
  silent! bnext     | bdelete
endf

fun! DiffToggle()
  echo "Implement DiffToggle()"
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· line numbers Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! NumberToggle()
  if &number == 0
    set foldcolumn=0 number number?
  else
    set foldcolumn=1 nonumber number?
  end
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· foldcolumn Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! FoldColToggle(fold_max)
  if &foldcolumn < a:fold_max
    call FoldColOn(a:fold_max)
  else
    call FoldColOff()
  endif
endf

fun! FoldColOn(fold_max)
  let w:use_num  = &number==1
  let w:use_rel  = &relativenumber==1
  let w:fold_min = &foldcolumn

  set nonumber norelativenumber
  let &foldcolumn = a:fold_max
endf

fun! FoldColOff()
  let [ &number, &relativenumber ] = [ w:use_num, w:use_rel ]
  let &foldcolumn = w:fold_min
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· syntax Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! SynStack()
  if !exists("*synstack")
    return
  endif
  echo map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")')
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· fonts Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! FontCycle(num)
  let font_nams = sort(keys(g:font_dict))
  let [ cur_nam, cur_hgt, cur_idx ] = CurFont(font_nams)
  let new_nam = NewFontNm(cur_idx, a:num, font_nams)
  let new_hgt = NewFontHt(cur_hgt, cur_nam, new_nam)

  let new_font = join([ new_nam, new_hgt ], ":h")
  exe "set guifont=" . escape(new_font, " ")
endf

fun! CurFont(font_nams)
  let [cur_nam, cur_hgt] = split(getfontname(), ':')
  let cur_idx = index(a:font_nams, cur_nam)
  return [cur_nam, cur_hgt, cur_idx]
endf

fun! NewFontNm(cur_idx, num, font_nams)
  let new_idx = (a:cur_idx + a:num) % len(a:font_nams)
  return a:font_nams[new_idx]
endf

fun! NewFontHt(cur_hgt, cur_nam, new_nam)
  let cur_adj = get(g:font_dict, a:cur_nam, 0)
  let new_adj = g:font_dict[a:new_nam]
  return a:cur_hgt - cur_adj + new_adj
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· statusline Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
function! AirlineInit()
  if !exists('g:airline_symbols')
    let g:airline_symbols = {}
  endif
  let g:airline_powerline_fonts = 1
  let g:airline#extensions#tabline#enabled = 1
  let g:airline#extensions#tabline#left_sep = ' '
  let g:airline#extensions#tabline#left_alt_sep = '|'
  let g:airline_detect_whitespace=0
  let g:airline_section_z = '%v : %l/%L (%n)'
  " let g:airline_theme='luna'
  " let g:airline_theme='molokai'
  " let g:airline_theme='laederon'
  " let g:airline_theme='ubaryd'
  let g:airline_theme='today'
  " let g:airline_theme='murmur'
endfunction

call AirlineInit()

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· colors Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! ToggleBG()
  if  exists("g:colors_name") | let cur_colo = g:colors_name | endif

  if &background=='dark' | set background=light
  else                   | set background=dark | endif

  if !exists("g:colors_name") && exists("cur_colo")
    let g:colors_name = cur_colo
  endif
endf

fun! ColorCycle(num)
  let cur_idx = index( g:nice_schemes, g:colors_name )
  let new_idx = (cur_idx + a:num) % len(g:nice_schemes)
  let new_nam = g:nice_schemes[new_idx]
  exe "colorscheme " . new_nam
endf

fun! TransparencyToggle(transpr)
  if exists("g:transparency_memo")
    let &transparency = g:transparency_memo
    unlet g:transparency_memo
  else
    let g:transparency_memo = &transparency
    let &transparency=a:transpr
  end
endf

fun! ColorColToggle()
  if &colorcolumn == ""
    set colorcolumn=80
  else
    set colorcolumn=
  endif
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· cursor Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
fun! RestoreCrsr()
  if line("'\"") > 1 && line("'\"") <= line("$")
    exe "normal! g`\""
  endif
endf

fun! CursorLineToggle()
  highlight! CursorLineClear guibg=NONE guifg=NONE gui=NONE ctermbg=NONE ctermfg=NONE cterm=NONE
  if exists("w:cursorline_memo")
    highlight! link CursorLine CursorLine
    unlet w:cursorline_memo
  else
    highlight! link CursorLine CursorLineClear
    let w:cursorline_memo = 1
  end
endf

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· braces Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
function! NextTextObject(motion)
  echo
  let c = nr2char(getchar())
  execute "normal! f" . c . "v" . a:motion . c
endfunction

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· git Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
"Git branch
function! GitBranch()
    let branch = system("git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* //'")
    if branch != ''
      return '(' . substitute(branch, '\n', '', 'g') . ')'
    endif
    return ''
endfunction

function! ReLoadBuffers()
  set autoread
  checktime
  set noautoread
endfunction

" Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· keyboard Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· {{{2
function! Keyboard(type)
   if a:type == "workman"
     call QWERTYUnmaps()
     call WorkmanMaps()
     echo "Workman mappings enabled"
   else
     call WorkmanUnmaps()
     call QWERTYMaps()
     echo "QWERTY mappings enabled"
   endif
endfunction
